<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>UARL | Russell Circumplex Engine</title>
    <style>
        body { font-family: 'Inter', system-ui, sans-serif; background: #fff; margin: 0; display: flex; height: 100vh; overflow: hidden; }
        #sidebar { width: 400px; background: #f8f9fa; padding: 20px; border-right: 1px solid #eee; overflow-y: auto; }
        #viewer { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        canvas { background: #fff; box-shadow: 0 0 50px rgba(0,0,0,0.02); border-radius: 50%; }
        .controls { margin-bottom: 20px; border-bottom: 2px solid #111; padding-bottom: 15px; }
        .btn { width: 100%; padding: 12px; font-weight: bold; cursor: pointer; border-radius: 6px; border: none; margin-bottom: 8px; transition: 0.2s; }
        .btn-primary { background: #111; color: #fff; }
        .btn-outline { background: #fff; border: 1px solid #111; color: #111; }
        .emotion-card { display: flex; align-items: center; background: #fff; padding: 8px; margin-top: 5px; border: 1px solid #eee; font-size: 0.75rem; border-radius: 4px; }
        h2 { font-size: 1.2rem; margin: 0 0 10px 0; }
        .label-grid { color: #ccc; font-size: 0.65rem; font-weight: bold; letter-spacing: 2px; margin-top: 20px; text-transform: uppercase; }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="controls">
        <h2>UARL Engine</h2>
        <button class="btn btn-primary" onclick="loadAllData()">INITIALIZE EMPIRICAL SET</button>
        <button class="btn btn-outline" onclick="toggleRotation()">ROTATE 45° (COMPLEMENTARY)</button>
        <button class="btn btn-outline" style="border-color:#ccc; color:#999" onclick="saveImage()">DOWNLOAD PNG</button>
    </div>
    <div id="list"></div>
</div>

<div id="viewer">
    <canvas id="canvas"></canvas>
    <div class="label-grid">Perceptual Affective Field</div>
</div>

<script src="affective_data.js"></script>
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let activeEmotions = [];
    let isRotated = false;

    function resize() {
        const size = Math.min(window.innerWidth - 460, window.innerHeight - 150);
        canvas.width = size; canvas.height = size;
        draw();
    }
    window.onresize = resize;
    resize();

    function loadAllData() {
        // Clear list first
        activeEmotions = AFFECTIVE_DATA.map(d => ({ ...d, visible: true, id: Math.random() }));
        updateUI();
        draw();
    }

    function toggleRotation() { 
        isRotated = !isRotated; 
        draw(); 
    }

    function toggleVis(id) {
        const em = activeEmotions.find(e => e.id === id);
        if(em) em.visible = !em.visible;
        draw();
    }

    function updateUI() {
        const list = document.getElementById('list');
        list.innerHTML = '';
        activeEmotions.forEach(e => {
            const div = document.createElement('div');
            div.className = 'emotion-card';
            div.style.borderLeft = `4px solid ${e.color}`;
            div.innerHTML = `
                <input type="checkbox" ${e.visible ? 'checked' : ''} onchange="toggleVis(${e.id})">
                <span style="flex:1; margin-left:10px;"><strong>${e.name}</strong></span>
                <span style="color:#999">${e.angle}°</span>
            `;
            list.appendChild(div);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const radius = canvas.width * 0.42;

        // 1. Primary Axes (Pleasure-Displeasure / Arousal-Sleep)
        ctx.strokeStyle = '#f0f0f0'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.stroke();
        
        // Draw standard axes
        ctx.beginPath(); ctx.moveTo(cx-radius, cy); ctx.lineTo(cx+radius, cy); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx, cy-radius); ctx.lineTo(cx, cy+radius); ctx.stroke();

        // 2. Rotated Axes (Excitement-Depression / Distress-Relaxation)
        if (isRotated) {
            ctx.strokeStyle = '#ffdede'; // Light Red for the alternative perspective
            ctx.setLineDash([5, 5]);
            
            // 45 degrees and 135 degrees lines
            [45, 135].forEach(deg => {
                const r = (deg * Math.PI) / 180;
                ctx.beginPath();
                ctx.moveTo(cx - Math.cos(r)*radius, cy - Math.sin(r)*radius);
                ctx.lineTo(cx + Math.cos(r)*radius, cy + Math.sin(r)*radius);
                ctx.stroke();
            });
            ctx.setLineDash([]);
            
            // Labels for Rotated Dimensions
            ctx.fillStyle = '#ffaaaa'; ctx.font = '8px Inter';
            ctx.fillText('EXCITEMENT', cx + Math.cos(Math.PI/4)*radius - 20, cy - Math.sin(Math.PI/4)*radius - 10);
            ctx.fillText('DEPRESSION', cx - Math.cos(Math.PI/4)*radius - 20, cy + Math.sin(Math.PI/4)*radius + 20);
        }

        // Standard Axis Labels
        ctx.fillStyle = '#bbb'; ctx.font = 'bold 10px Inter';
        ctx.fillText('PLEASURE', cx + radius + 10, cy + 4);
        ctx.fillText('DISPLEASURE', cx - radius - 80, cy + 4);
        ctx.fillText('AROUSAL', cx - 22, cy - radius - 15);
        ctx.fillText('SLEEPINESS', cx - 28, cy + radius + 25);

        // 3. Draw Fuzzy Sets (Multiply Mode)
        ctx.globalCompositeOperation = 'multiply';
        activeEmotions.forEach(e => {
            if (!e.visible) return;
            // Angle math: Russell 0 is East, counter-clockwise. Canvas 0 is East, clockwise.
            // We multiply by -1 to reverse direction.
            const rad = (e.angle * Math.PI) / 180 * -1;
            const vLen = radius * e.p;
            const tx = cx + Math.cos(rad) * vLen;
            const ty = cy + Math.sin(rad) * vLen;
            const fuzzRadius = e.spread * 15;

            const grad = ctx.createRadialGradient(tx, ty, 0, tx, ty, fuzzRadius);
            grad.addColorStop(0, e.color + '66');
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(tx, ty, fuzzRadius, 0, Math.PI*2); ctx.fill();

            ctx.strokeStyle = e.color + '44'; ctx.setLineDash([2, 3]);
            ctx.beginPath(); ctx.arc(tx, ty, fuzzRadius, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]);
        });

        // 4. Draw Core Points
        ctx.globalCompositeOperation = 'source-over';
        activeEmotions.forEach(e => {
            if (!e.visible) return;
            const rad = (e.angle * Math.PI) / 180 * -1;
            const vLen = radius * e.p;
            const tx = cx + Math.cos(rad) * vLen;
            const ty = cy + Math.sin(rad) * vLen;

            ctx.fillStyle = e.color;
            ctx.beginPath(); ctx.arc(tx, ty, 4, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = '#000'; ctx.font = 'bold 10px Inter';
            ctx.fillText(e.name.toUpperCase(), tx + 10, ty - 5);
        });
    }

    function saveImage() {
        const link = document.createElement('a');
        link.download = 'uarl_scientific_map.png';
        link.href = canvas.toDataURL();
        link.click();
    }
</script>
</body>
</html>
